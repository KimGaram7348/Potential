module PC.Compiler (compiler) where

import Control.Monad
import Control.Monad.Reader (ask)

import Language.Haskell.Interpreter hiding (get)
import Language.Haskell.Interpreter.Unsafe

import System.Directory (createDirectoryIfMissing)
import System.IO (withFile, IOMode(..), hPutStrLn)

import qualified GHC as GHC

import PC.Config
import PC.Base
import PC.Source

import Potential.Printing

compiler :: Config -> IO ()
compiler cfg =
     do let compilerState = CompilerState { msgDepth = 0 }
	putStrLn $ "Configuration: " ++ show cfg ++ "\n"
	(r, _) <- runCompiler (runInterpreter compiler) cfg compilerState
	case r of
	  Left err  -> printInterpreterError err
	  Right () -> putStrLn "Done compiling"
  where printInterpreterError err = putStrLn $ "Ups... " ++ (show err)
	compiler =
	     do -- set our flags
		unsafeSetGhcOption "-fcontext-stack=160"
		set [ languageExtensions :=
			[ NoImplicitPrelude
			, NoMonomorphismRestriction
			, QuasiQuotes
			, FlexibleContexts
			, MultiParamTypeClasses
			, UndecidableInstances
			, TypeFamilies
			] ]
		-- one file at a time
		cfg <- lift ask
		fns <- inDepth $ analyzeFile (target cfg)
		case mode cfg of
		  Check -> doCheck fns
		  Compile outdir -> doCompile (path $ target cfg) outdir fns

doCheck fns =
     do say "Functions:"
	inDepth $ mapM_ (\f -> say $ fname f ++ " defined at " ++ floc f) fns

doCompile mod outdir fns =
     do let outname = outdir ++ "/" ++ mod ++ ".S"
	say $ "Rendering to assembly: `" ++ outname ++ "'"
	liftIO $ createDirectoryIfMissing True outdir
	liftIO $ withFile outname WriteMode $ \h ->
		     do hPutStrLn h $ "/* Generated by the Potential Compiler"
			hPutStrLn h $ " * 2010 http://potential-lang.org"
			hPutStrLn h $ " *"
			hPutStrLn h $ " * Initial source module: `" ++ mod ++"'"
			hPutStrLn h $ " */"
			mapM_ (doCompileFile h) fns

doCompileFile h fn =
     do putStrLn $ "  " ++ fname fn ++ "..."
	let indent = replicate 4 ' '
	hPutStrLn h $ fname fn ++ ":"
	hPutStrLn h $ indent ++ "// Defined at " ++ floc fn
	unless (null $ fnotes fn) $
	     do hPutStrLn h $ indent ++ "//"
		hPutStrLn h $ indent ++ "// Notes: " ++ show (fnotes fn)
		hPutStrLn h $ indent ++ "//"
	mapM_ (\c -> hPutStrLn h $ indent ++ show c) (fcode fn)
	hPutStrLn h ""

