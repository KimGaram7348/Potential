{-
  Copyright 2010 Timothy Carstens    carstens@math.utah.edu

  This file is part of the Potential Standard Library.

    The Potential Standard Library is free software: you can redistribute it
    and/or modify it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 3 of the License.

    The Potential Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
-}
{-# LANGUAGE
	TemplateHaskell,
	DeriveDataTypeable #-}
module Language.Potential.DataStructure.AbstractSyntax
	( ByteOffset, BitOffset, Partial, FieldWithBitOffset
	, UserStruct(..)
	, Field(..)
	, isVarField
	, Bit(..)
	, pretty_field_show
	, pretty_bit_show
	) where

import Prelude
import Data.Typeable
import Data.Data
import qualified Language.Haskell.TH as TH
import qualified Language.Haskell.TH.Syntax as THS

type ByteOffset = Integer
type BitOffset  = Integer
type Partial = ([Field], ByteOffset)
type FieldWithBitOffset = (Field, BitOffset)

-- Types to model the struct we're going to defined
-- Instances are generated by the parser
data UserStruct =
     UserStruct { struct_name :: String
		, fields :: [[Field]] -- assumes these are partitioned such that
				      -- each entry is 64 bits
		}
  deriving (Eq, Show, Data, Typeable)

instance THS.Lift UserStruct where
  lift us = foldl TH.appE [| UserStruct |]
		    [ THS.lift $ struct_name us
		    , THS.lift $ fields us
		    ]

data Field =
    VarField { field_name :: String
	     , field_size :: Integer
	     }
  | ConstField { field_size :: Integer
	       , field_val :: [Bit]
	       }
  | ReservedField { field_size :: Integer }
  deriving (Eq, Show, Data, Typeable)

instance THS.Lift Field where
  lift (VarField n s) = foldl TH.appE [| VarField |]
				      [ THS.lift n, THS.lift s ]
  lift (ConstField s bs) = foldl TH.appE [| ConstField |]
					 [ THS.lift s, THS.lift bs ]
  lift (ReservedField s) = TH.appE [| ReservedField |] (THS.lift s)

data Bit = ConstBit0 | ConstBit1
  deriving (Eq, Show, Data, Typeable)

instance THS.Lift Bit where
  lift (ConstBit0) = [| ConstBit0 |]
  lift (ConstBit1) = [| ConstBit1 |]



isVarField (a@VarField{}) = True
isVarField _ = False


-- These next two functions are basically helpers for error reporting
-- by [$struct| ... |]

pretty_field_show (VarField n s) =
  "    " ++ show n ++ ": " ++ show s ++ "\n"
pretty_field_show (ConstField s b) =
  "    const field (" ++ show s ++ " bits): " ++ pretty_bit_show b ++ "\n"
pretty_field_show (ReservedField s) =
  "    reserved field (" ++ show s ++ " bits)\n"


pretty_bit_show [] = ""
pretty_bit_show (ConstBit0:bs) = '0':(pretty_bit_show bs)
pretty_bit_show (ConstBit1:bs) = '1':(pretty_bit_show bs)

