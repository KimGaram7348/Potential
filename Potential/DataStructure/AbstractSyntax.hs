{-# LANGUAGE
	DeriveDataTypeable #-}
module Potential.DataStructure.AbstractSyntax
	( UserStruct(..)
	, Field(..)
	, isVarField
	, Bit(..)
	, pretty_field_show
	, pretty_bit_show
	) where

import Data.Typeable
import Data.Data

-- Types to model the struct we're going to defined
-- Instances are generated by the parser
data UserStruct =
     UserStruct { struct_name :: String
		, fields :: [[Field]] -- assumes these are partitioned such that
				      -- each entry is 64 bits
		}
  deriving (Eq, Show, Data, Typeable)

data Field =
    VarField { field_name :: String
	     , field_size :: Integer
	     }
  | ConstField { field_size :: Integer
	       , field_val :: [Bit]
	       }
  | ReservedField { field_size :: Integer }
  deriving (Eq, Show, Data, Typeable)

isVarField (a@VarField{}) = True
isVarField _ = False

pretty_field_show (VarField n s) =
  "    " ++ show n ++ ": " ++ show s ++ "\n"
pretty_field_show (ConstField s b) =
  "    const field (" ++ show s ++ " bits): " ++ pretty_bit_show b ++ "\n"
pretty_field_show (ReservedField s) =
  "    reserved field (" ++ show s ++ " bits)\n"

data Bit = ConstBit0 | ConstBit1
  deriving (Eq, Show, Data, Typeable)

pretty_bit_show [] = ""
pretty_bit_show (ConstBit0:bs) = '0':(pretty_bit_show bs)
pretty_bit_show (ConstBit1:bs) = '1':(pretty_bit_show bs)

