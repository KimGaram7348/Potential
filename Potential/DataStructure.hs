{-# LANGUAGE
	TemplateHaskell,
	QuasiQuotes,
	DeriveDataTypeable #-}
module Potential.DataStructure (struct) where

-- For building the ``struct'' quasi-quoter
import Data.Typeable
import Data.Data
import Data.Generics.Aliases (extQ)
import Language.Haskell.TH.Quote
import Text.ParserCombinators.Parsec
import qualified Text.ParserCombinators.Parsec.Token as P
import Text.ParserCombinators.Parsec.Language (haskellDef)
-- We need template haskell for the magic we're about to perform
import qualified Language.Haskell.TH as TH


-- Types to model the struct we're going to defined
-- Instances are generated by the parser
data UserStruct =
     UserStruct { struct_name :: String
		, fields :: [Field]
		}
  deriving (Show, Data, Typeable)

data Field =
    VarField { field_name :: String
	     , field_size :: Integer
	     }
  | ConstField { field_size :: Integer
	       , field_val :: [Bit]
	       }
  | ReservedField { field_size :: Integer }
  deriving (Show, Data, Typeable)

pretty_field_show (VarField n s) = "    " ++ show n ++ ": " ++ show s ++ "\n"
pretty_field_show (ConstField s b) = "    const field (" ++ show s ++ " bits): " ++ pretty_bit_show b ++ "\n"
pretty_field_show (ReservedField s) = "    reserved field (" ++ show s ++ " bits)\n"

data Bit = ConstBit0 | ConstBit1
  deriving (Show, Data, Typeable)

pretty_bit_show [] = ""
pretty_bit_show (ConstBit0:bs) = '0':(pretty_bit_show bs)
pretty_bit_show (ConstBit1:bs) = '1':(pretty_bit_show bs)


-- This is actually exactly the language def we want, since the plan is to
-- define some new identifiers and types in Haskell (how convenient).  This
-- also means we can use Haskell style comments in the middle of our struct
-- definitions (very cool).
lexer = P.makeTokenParser haskellDef
whiteSpace = P.whiteSpace lexer
identifier = P.identifier lexer
integer    = P.integer lexer

parseStruct s = case parse structParser "(unknown)" s of
			Left err -> fail $ show err
			Right e -> return e

structParser =
     do whiteSpace
	structName   <- parse_name
	whiteSpace
	string "where"
	whiteSpace
	structFields <- many1 $ do f <- parse_field
				   whiteSpace
				   return f
	eof
	-- now verify that the struct can be broken up into chunks of 64
	-- bits
	let ps = partition structFields [] []
	if null ps
	  then return $ UserStruct structName structFields
	  else fail $ "Fields for struct " ++ show structName ++
		      " fail to partition into 64-bit chunks!\n" ++
		      "  Partitions: \n" ++
		      (concat $ concat $
		       map (\p -> ["   size: " ++
				   show (partition_size p) ++
				   " bits\n"] ++
				  map pretty_field_show p) ps)
  where parse_name =
	     do structName' <- upper
		structName'' <- identifier
		let structName = structName' : structName''
		return structName
	parse_field =
	     do f <- (try parse_field_const)
			<|> (try parse_field_reserved)
			<|> parse_field_var
		return f
	parse_field_const = 
	     do string "const"
		whiteSpace
		bits <- many1 parse_bit
		return $ ConstField (fromIntegral $ length bits) bits
	parse_bit =  (try $ char '0' >> return ConstBit0)
		 <|> (try $ char '1' >> return ConstBit1)
	parse_field_reserved =
	     do string "reserved"
		whiteSpace
		size <- integer
		return $ ReservedField size
	parse_field_var =
	     do name <- identifier
		-- fail if name == "reserved" or name == "const"
		case name of
		 "reserved" -> fail "Variable fields cannot be named `reserved'"
		 "const" -> fail "Variable fields cannot be named `const'"
		 _ -> do string "::"
			 whiteSpace
			 size <- integer
			 return $ VarField name size
	partition_size p = sum $ map field_size p
	partition [] p' ps =
	     let ps' = filter (\p -> 0 /= partition_size p) (ps ++ [p'])
	     in if any (\p -> 64 /= partition_size p) ps'
		  then ps'
		  else []
	partition (f:fs) p' ps
		| psize == 64 = partition fs [] (ps ++ [p'++[f]])
		| psize <  64 = partition fs (p' ++ [f]) ps
		| psize > 64  = ps ++ [p' ++ [f]]
	  where psize = partition_size (f:p')

struct = QuasiQuoter parseStructExp parseStructPat

antiE :: UserStruct -> Maybe TH.ExpQ
antiE us = let s = show us
	   in Just $ TH.litE $ TH.stringL s

parseStructExp :: String -> TH.ExpQ
parseStructExp s =
     do p <- parseStruct s
	dataToExpQ (const Nothing `extQ` antiE) p

parseStructPat :: String -> TH.PatQ
parseStructPat s = parseStruct s >>= dataToPatQ (const Nothing)

