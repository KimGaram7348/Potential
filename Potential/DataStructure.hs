{-# LANGUAGE
	ScopedTypeVariables,
	TemplateHaskell,
	QuasiQuotes,
	DeriveDataTypeable #-}
module Potential.DataStructure (struct, struct_diagram) where

-- For building the ``struct'' quasi-quoter
import Data.Typeable
import Data.Data
import Data.Generics.Aliases (extQ)
import Language.Haskell.TH.Quote
import Text.ParserCombinators.Parsec
import qualified Text.ParserCombinators.Parsec.Token as P
import Text.ParserCombinators.Parsec.Language (haskellDef)
-- We need template haskell for the magic we're about to perform
import qualified Language.Haskell.TH as TH

import Data.List
import Data.Char (digitToInt)


-- Types to model the struct we're going to defined
-- Instances are generated by the parser
data UserStruct =
     UserStruct { struct_name :: String
		, fields :: [Field]
		}
  deriving (Eq, Show, Data, Typeable)

data Field =
    VarField { field_name :: String
	     , field_size :: Integer
	     }
  | ConstField { field_size :: Integer
	       , field_val :: [Bit]
	       }
  | ReservedField { field_size :: Integer }
  deriving (Eq, Show, Data, Typeable)

pretty_field_show (VarField n s) = "    " ++ show n ++ ": " ++ show s ++ "\n"
pretty_field_show (ConstField s b) = "    const field (" ++ show s ++ " bits): " ++ pretty_bit_show b ++ "\n"
pretty_field_show (ReservedField s) = "    reserved field (" ++ show s ++ " bits)\n"

data Bit = ConstBit0 | ConstBit1
  deriving (Eq, Show, Data, Typeable)

pretty_bit_show [] = ""
pretty_bit_show (ConstBit0:bs) = '0':(pretty_bit_show bs)
pretty_bit_show (ConstBit1:bs) = '1':(pretty_bit_show bs)


-- This is actually exactly the language def we want, since the plan is to
-- define some new identifiers and types in Haskell (how convenient).  This
-- also means we can use Haskell style comments in the middle of our struct
-- definitions (very cool).
lexer = P.makeTokenParser haskellDef
whiteSpace = P.whiteSpace lexer
identifier = P.identifier lexer
integer    = P.integer lexer
typeName   = do structName' <- upper
		structName'' <- identifier
		let structName = structName' : structName''
		whiteSpace
		return structName
bit = (try $ char '0' >> return ConstBit0)
	<|> (try $ char '1' >> return ConstBit1)
fieldName = 
     do name <- identifier
	-- fail if name == "reserved" or name == "const"
	case name of
		"reserved" -> fail "Variable fields cannot be named `reserved'"
		"const"    -> fail "Variable fields cannot be named `const'"
		_ -> return name

parseStruct fname line col s =
	let p = do pos <- getPosition
		   let pos'  = setSourceLine pos line
		       pos'' = setSourceColumn pos' col
		   setPosition pos''
		   structParser
	in case parse p fname s of
		Left err -> fail $ show err
		Right e -> return e

structParser =
     do whiteSpace
	structName   <- typeName
	string "where" >> whiteSpace
	structFields <- many1 $ do f <- parse_field
				   whiteSpace
				   return f
	eof
	-- now verify that the struct can be broken up into chunks of 64
	-- bits
	let ps = partition structFields [] []
	if null ps
	  then return $ UserStruct structName structFields
	  else fail $ "Fields for struct " ++ show structName ++
		      " fail to partition into 64-bit chunks!\n" ++
		      "  Partitions: \n" ++
		      (concat $ concat $
		       map (\p -> ["   size: " ++
				   show (partition_size p) ++
				   " bits\n"] ++
				  map pretty_field_show p) ps)
  where parse_field =
	     do f <- (try parse_field_const)
			<|> (try parse_field_reserved)
			<|> parse_field_var
		return f
	parse_field_const = 
	     do string "const"
		whiteSpace
		bits <- many1 bit
		return $ ConstField (fromIntegral $ length bits) bits
	parse_field_reserved =
	     do string "reserved"
		whiteSpace
		size <- integer
		return $ ReservedField size
	parse_field_var =
	     do name <- fieldName
		string "::"
		whiteSpace
		size <- integer
		return $ VarField name size
	partition_size p = sum $ map field_size p
	partition [] p' ps =
	     let ps' = filter (\p -> 0 /= partition_size p) (ps ++ [p'])
	     in if any (\p -> 64 /= partition_size p) ps'
		  then ps'
		  else []
	partition (f:fs) p' ps
		| psize == 64 = partition fs [] (ps ++ [p'++[f]])
		| psize <  64 = partition fs (p' ++ [f]) ps
		| psize > 64  = ps ++ [p' ++ [f]]
	  where psize = partition_size (f:p')


parseStructDiagram fname line col s =
	let p = do pos <- getPosition
		   let pos'  = setSourceLine pos line
		       pos'' = setSourceColumn pos' col
		   setPosition pos''
		   structDiagramParser
	in case parse p fname s of
		Left err -> fail $ show err
		Right e -> return e

structDiagramParser =
     do whiteSpace'
	structName   <- typeName
	whiteSpace'
	structFields <- many1 parse_diagram_field
	let structFields' = sortBy (\(_,a :: Integer) (_,b :: Integer) ->
					compare a b)
				   structFields
	eof
	return $ UserStruct structName $ concat $ map fst structFields'
  where whiteSpace' = try parse_diagram_comment <|> whiteSpace
	bitpos = do digits <- many1 digit
		    return $ fromIntegral $ convert 0 digits
	  where convert n [] = n
		convert n (d:ds) = convert (10*n + digitToInt d) ds
	parse_diagram_comment =
	     do whiteSpace
		char '('
		manyTill anyChar (try $ char '\n')
		whiteSpace'
	parse_diagram_field =
	     do ranges <- parse_top
		(fs, byte_offset) <- parse_middle ranges
		parse_bottom
		whiteSpace'
		return (fs, byte_offset)
	parse_top =
	     do char ('|')
		(ranges :: [[Integer]]) <- sepEndBy1 (try parse_top') (char '|')
		whiteSpace'
		-- now we make sure the ranges are actually a partition
		-- of the interval [0, 31].
		let ranges' = concat ranges
		if decreasing_partition ranges'
			then return ranges
			else fail $ "Bit ranges do not partition [0, 31].\n" ++
				    "Numbers given: " ++ show ranges'
	  where decreasing_partition (31:ns) = decreasing_partition' ns
		decreasing_partition _ = False
		decreasing_partition' [] = False
		decreasing_partition' [0] = True
		decreasing_partition' [a, 0] | a > 0 = True
					     | otherwise = False
		decreasing_partition' (a:b:ns)
			| a > b = decreasing_partition' (b:ns)
			| otherwise = False
		parse_top' =
		     do many (char '-')
			ulimit <- bitpos >>= \l -> return [l]
			many (char '-')
			llimit <- (try $ bitpos >>= \l -> return [l])
				  <|> (return [])
			many (char '-')
			case (ulimit, llimit) of
			  ([u], [l]) -> if u > l
					  then return [u,l]
					  else fail $ show u ++ " <= " ++ show l
			  ([u], [])  -> return [u]
	parse_middle rs = do char '|'
			     parse_middle' rs []
	  where parse_middle' [] fs =
		     do whiteSpace
			byte_offset <- integer
			whiteSpace'
			return (fs, byte_offset)
		parse_middle' (r:rs) fs =
		     do whiteSpace
			f <- parse_field r (span r)
			char '|'
			parse_middle' rs (f:fs)
		  where span [a] = 1
			span [a,b] = a-b+1
	parse_field r size =
		(try $ do string "reserved"
			  whiteSpace
			  return $ ReservedField size)
	    <|> (try $ do name <- fieldName
			  whiteSpace
			  return $ VarField name size)
	    <|> (do bits <- many1 bit
		    whiteSpace
		    let bl = fromIntegral $ length bits
		    if size == bl
			then return $ ConstField size bits
			else fail $ "Field is defined to be " ++ show size ++
				    " bits, but there are " ++ show bl ++
				    " bits in this field (location " ++
				    show r ++ ")")
	parse_bottom =
	     do char '|'
		many (char '-')
		char '|'
		whiteSpace'

struct = QuasiQuoter (parseStructExp parseStruct)
		     (parseStructPat parseStruct)
struct_diagram = QuasiQuoter (parseStructExp parseStructDiagram)
			     (parseStructPat parseStructDiagram)

antiE :: UserStruct -> Maybe TH.ExpQ
antiE us = let s = show us
	   in Just $ TH.litE $ TH.stringL s

parseStructExp parser s =
     do loc <- TH.location
	let fname = TH.loc_filename loc
	    (line, col) = TH.loc_start loc
	parsed <- parser fname line col s
	dataToExpQ (const Nothing `extQ` antiE) parsed

parseStructPat parser s =
     do loc <- TH.location
	let fname = TH.loc_filename loc
	    (line, col) = TH.loc_start loc
	parsed <- parser fname line col s
	dataToPatQ (const Nothing) parsed

