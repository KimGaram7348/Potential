{-
  Copyright 2010 Timothy Carstens    carstens@math.utah.edu

  This file is part of the Potential Standard Library.

    The Potential Standard Library is free software: you can redistribute it
    and/or modify it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 3 of the License.

    The Potential Compiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
-}
{-# LANGUAGE
	TemplateHaskell,
	DeriveDataTypeable #-}
module Language.Potential.DataStructure.AbstractSyntax
	( ByteOffset, BitOffset, Partial, FieldWithBitOffset
	, UserStruct(..)
	, Field(..)
	, isVarField
	, Bit(..)
	) where

import Prelude
import Data.Typeable
import Data.Data
import qualified Language.Haskell.TH as TH
import qualified Language.Haskell.TH.Syntax as THS
import Text.PrettyPrint.Leijen

type ByteOffset = Integer
type BitOffset  = Integer
type Partial = ([Field], ByteOffset)
type FieldWithBitOffset = (Field, BitOffset)

-- Types to model the struct we're going to defined
-- Instances are generated by the parser
data UserStruct =
     UserStruct { struct_name :: String
		, constructors :: [Constructor]
		}
  deriving (Eq, Show, Data, Typeable)

instance Pretty UserStruct where
  pretty us = text (struct_name us)
		<+> linebreak
		<+> prettyList (constructors us)

instance THS.Lift UserStruct where
  lift us = foldl TH.appE [| UserStruct |]
		    [ THS.lift $ struct_name us
		    , THS.lift $ constructors us
		    ]

data Constructor =
    Constructor { constr_name :: String
		, constr_id :: Maybe [Bit]
		, fields :: [Field]
		}
  deriving (Eq, Show, Data, Typeable)

instance Pretty Constructor where
  pretty c = let rep = case constr_id c of
			Nothing -> text "auto"
			Just bs -> prettyList bs
	     in (pretty $ constr_name c) <+> space <+> parens rep
		    <+> linebreak
		    <+> nest 2 (prettyList (fields c))

instance THS.Lift Constructor where
  lift c = foldl TH.appE [| Constructor |]
			 [ THS.lift $ constr_name c
			 , THS.lift $ constr_id c
			 , THS.lift $ fields c
			 ]

data Field =
    VarField { field_name :: String
	     , field_size :: Integer
	     , representation :: Maybe Representation
	     }
  | ConstField { field_size :: Integer
	       , field_val :: [Bit]
	       }
  | ReservedField { field_size :: Integer }
  deriving (Eq, Show, Data, Typeable)

instance Pretty Field where
  pretty f@(VarField{}) = let rep = case representation f of
					Nothing -> text "auto"
					Just r  -> linebreak
							<+> nest 2 (pretty r)
			  in pretty (field_name f)
				<+> text "Size: " <+> pretty (field_size f)
				<+> text ", Representation: " <+> rep
  pretty (ConstField{ field_val = b }) = text "Constant " <+> prettyList b
  pretty (ReservedField{ field_size = s}) = text $ "Reserved (" ++ show s ++ ")"
  prettyList fs = let pfs = map (\f -> pretty f <+> linebreak) fs
		  in foldl (<+>) empty pfs

instance THS.Lift Field where
  lift (VarField n s r) = foldl TH.appE [| VarField |]
					[ THS.lift n, THS.lift s, THS.lift r ]
  lift (ConstField s bs) = foldl TH.appE [| ConstField |]
					 [ THS.lift s, THS.lift bs ]
  lift (ReservedField s) = TH.appE [| ReservedField |] (THS.lift s)

data Representation =
    Representation { field_type :: String
		   , constr_bf  :: [String]
		   , constr_reps :: [ConstrRepresentation]
		   }
  deriving (Eq, Show, Data, Typeable)

instance Pretty Representation where
  pretty r = let cr = if length (constr_reps r) > 0
			then linebreak <+> nest 2 (prettyList $ constr_reps r)
			else text "auto"
	     in text "Type: " <+> pretty (field_type r)
		  <+> linebreak
		  <+> text "Constructor stored in: " <+> pretty (constr_bf r)
		  <+> text "Constructors represented by:" <+> space <+> cr

instance THS.Lift Representation where
  lift r = foldl TH.appE [| Representation |]
			 [ THS.lift $ field_type r
			 , THS.lift $ constr_bf r
			 , THS.lift $ constr_reps r
			 ]

data ConstrRepresentation =
    ConstrRepresentation { constr_rep_name :: String
			 , constr_rep :: [Bit]
			 }
  deriving (Eq, Show, Data, Typeable)

instance THS.Lift ConstrRepresentation where
  lift r = foldl TH.appE [| ConstrRepresentation |]
			 [ THS.lift $ constr_rep_name r
			 , THS.lift $ constr_rep r
			 ]

instance Pretty ConstrRepresentation where
  pretty cr = pretty (constr_rep_name cr) <+> text " : "
		<+> prettyList (constr_rep cr)

data Bit = ConstBit0 | ConstBit1
  deriving (Eq, Show, Data, Typeable)

instance Pretty Bit where
  pretty ConstBit0 = text "0"
  pretty ConstBit1 = text "1"
  prettyList bs = foldl (<+>) empty (map pretty bs)

instance THS.Lift Bit where
  lift (ConstBit0) = [| ConstBit0 |]
  lift (ConstBit1) = [| ConstBit1 |]


isVarField (a@VarField{}) = True
isVarField _ = False


